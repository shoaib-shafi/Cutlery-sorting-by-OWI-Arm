function [BW,maskedRGBImage] = createMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 03-Nov-2023
%------------------------------------------------------
arduinoObj = arduino("COM6", "Mega2560", Libraries = ["Adafruit/MotorShieldV2","I2C","Servo"])
shield = addon(arduinoObj,'Adafruit\MotorShieldV2')
addrs = scanI2CBus(arduinoObj,0)
dcm_1 = dcmotor(shield,1)
dcm_2 = dcmotor(shield,2)
dcm_3 = dcmotor(shield,3)
dcm_4 = dcmotor(shield,4)

centroid_list_x=[];
centroid_list_y=[]
while(true)
cam = webcam(2);
RGB = snapshot(cam);
%figure(1);
%imshow(RGB);
% Convert RGB image to chosen color space
%function [BW,maskedRGBImage] = createMask(RGB)

I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.847;
channel1Max = 0.009;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.000;
channel2Max = 0.067;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.952;
channel3Max = 1.000;

% Create mask based on chosen histogram thresholds
sliderBW = ( (I(:,:,1) >= channel1Min) | (I(:,:,1) <= channel1Max) ) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

CC = bwconncomp(sliderBW);
s = regionprops(CC,'Centroid','Area');
centroids = cat(1,s.Centroid);
areas = cat(1,s.Area);
hold off
[m,ind] = max(areas); % find the largest connected component
figure(3);clf;
imshow(double(sliderBW));
hold on
%plot(centroids(:,1),centroids(:,2),'b*')
% for i = 1:numel(areas) % this shows all the spots
% text(centroids(i,1),centroids(i,2),num2str(areas(i) ),'color','r')
% end
plot(centroids(ind,1),centroids(ind,2),'m*','markersize',32);
class(centroids)
centroid_x_object=  centroids(ind,1)
centroid_y_object=  centroids(ind,2)

% put a star on the largest connected component.
% This is where you should aim your robot.
%disp(centroid_list)


%{
if movement_x >100
    dcm_x.Speed=0.2;
    start(dcm_x)
elseif movement_x<100 && movement_x >0
    stop(dcm_x)

elseif movement_x<-100
    dcm_x.Speed=-0.2
    start(dcm_x)
else stop(dcm_x)
end
%}
while(true)
cam = webcam(2);
RGB_2 = snapshot(cam);
    % Convert RGB image to chosen color space
I = rgb2hsv(RGB_2);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.521;
channel1Max = 0.695;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.274;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.000;
channel3Max = 1.000;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB_2;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
CC = bwconncomp(sliderBW);
s = regionprops(CC,'Centroid','Area');
centroids = cat(1,s.Centroid);
areas = cat(1,s.Area);
[m,ind] = max(areas); % find the largest connected component
figure(3);clf;
imshow(double(sliderBW));
hold on
%plot(centroids(:,1),centroids(:,2),'b*')
% for i = 1:numel(areas) % this shows all the spots
% text(centroids(i,1),centroids(i,2),num2str(areas(i) ),'color','r')
% end
plot(centroids(ind,1),centroids(ind,2),'m*','markersize',32);
class(centroids)
centroid_x_robot= centroids(ind,1)
centroid_y_robot= centroids(ind,2)


%{
if centroid_y_robot < centroid_y_object-100
    dcm_2.Speed =0.75
    start(dcm_2)
elseif centroid_y_robot>centroid_y_object+100
        dcm_2.Speed=-0.75
        start(dcm_2)
else stop(dcm_2)
end
%}
    
disp(centroid_x_object)
disp(centroid_y_object)
disp(centroid_x_robot)
disp(centroid_y_robot)

if centroid_x_robot < centroid_x_object-100
    dcm_1.Speed =0.75
    start(dcm_1)
elseif centroid_x_robot>centroid_x_object+100
        dcm_1.Speed=-0.75
        start(dcm_1)

else stop(dcm_1)
end
if centroid_x_robot > centroid_x_object-100 && centroid_x_robot<centroid_x_object+100 
stop(dcm_1)
break
end
end
clear cam;
camera_3=webcam(1);
captured_image=snapshot(camera_3);
loadedData = load('trained_model_1.mat');

% Access the loaded network
loadedNet = loadedData.net;

testImage = imresize(captured_image, [224, 224]);
figure(2);
imshow(testImage);
% Preprocess the image if necessary
% ...
% Use the loaded network for prediction
predictedLabels = classify(loadedNet, testImage);
disp("done classifying");
% Display the results
disp(predictedLabels);
clear("camera_3");
while(true) 
if readVoltage(arduinoObj,'A8') >2.5 
    dcm_3.Speed= 1
    start(dcm_3)
else
    stop(dcm_3)
    if readVoltage(arduinoObj,'A9') >0.82
        dcm_2.Speed = 0.5
        start(dcm_2)
    else
        writeDigitalPin(a,D5,1)
        stop(dcm_2)
        pause(5)
        break
    end
end
end
while(true)
    if readVoltage(arduinoObj, 'A9')<1.5
        dcm_2.Speed = -0.5
        start(dcm_2)
    else 
        stop(dcm_2)
        if readVoltage(arduinoObj, 'A8')<2.9
            dcm_3.Speed = -0.5
            start(dcm_3)
        else
            stop(dcm_3)
            break
        end
    end
end
if predictedLabels == 'spoon'
cam = webcam(2);
RGB_3 =snapshot(cam)
% Convert RGB image to chosen color space
I = rgb2hsv(RGB_3);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.007;
channel1Max = 0.059;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.567;
channel2Max = 0.715;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.720;
channel3Max = 1.000;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB_3;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
CC = bwconncomp(sliderBW);
s = regionprops(CC,'Centroid','Area');
centroids = cat(1,s.Centroid);
areas = cat(1,s.Area);
[m,ind] = max(areas); % find the largest connected component
figure(3);clf;
imshow(double(sliderBW));
hold on
%plot(centroids(:,1),centroids(:,2),'b*')
% for i = 1:numel(areas) % this shows all the spots
% text(centroids(i,1),centroids(i,2),num2str(areas(i) ),'color','r')
% end
plot(centroids(ind,1),centroids(ind,2),'m*','markersize',32);
class(centroids)
centroid_x_detect= centroids(ind,1)
centroid_y_detect= centroids(ind,2)
elseif predictedLabels == 'fork'
    cam = webcam(2);
    RGB_4=snapshot(cam)
    I = rgb2hsv(RGB_4);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.266;
channel1Max = 0.537;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.170;
channel2Max = 0.459;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.617;
channel3Max = 1.000;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB_4;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
CC = bwconncomp(sliderBW);
s = regionprops(CC,'Centroid','Area');
centroids = cat(1,s.Centroid);
areas = cat(1,s.Area);
[m,ind] = max(areas); % find the largest connected component
figure(3);clf;
imshow(double(sliderBW));
hold on
%plot(centroids(:,1),centroids(:,2),'b*')
% for i = 1:numel(areas) % this shows all the spots
% text(centroids(i,1),centroids(i,2),num2str(areas(i) ),'color','r')
% end
plot(centroids(ind,1),centroids(ind,2),'m*','markersize',32);
class(centroids)
centroid_x_detect= centroids(ind,1)
centroid_y_detect= centroids(ind,2)
elseif predictedLabels == 'Knife'
    cam = webcam(2);
    RGB_5=snapshot(cam)
    I = rgb2hsv(RGB_5);
 

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.091;
channel1Max = 0.220;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.198;
channel2Max = 0.393;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.811;
channel3Max = 1.000;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB_5;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
CC = bwconncomp(sliderBW);
s = regionprops(CC,'Centroid','Area');
centroids = cat(1,s.Centroid);
areas = cat(1,s.Area);
[m,ind] = max(areas); % find the largest connected component
figure(3);clf;
imshow(double(sliderBW));
hold on
%plot(centroids(:,1),centroids(:,2),'b*')
% for i = 1:numel(areas) % this shows all the spots
% text(centroids(i,1),centroids(i,2),num2str(areas(i) ),'color','r')
% end
plot(centroids(ind,1),centroids(ind,2),'m*','markersize',32);
class(centroids)
centroid_x_detect= centroids(ind,1)
centroid_y_detect= centroids(ind,2)


end
while(true)
RGB_6 = snapshot(cam);
    % Convert RGB image to chosen color space
I = rgb2hsv(RGB_6);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.521;
channel1Max = 0.695;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.274;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.000;
channel3Max = 1.000;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB_6;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
CC = bwconncomp(sliderBW);
s = regionprops(CC,'Centroid','Area');
centroids = cat(1,s.Centroid);
areas = cat(1,s.Area);
[m,ind] = max(areas); % find the largest connected component
figure(3);clf;
imshow(double(sliderBW));
hold on
%plot(centroids(:,1),centroids(:,2),'b*')
% for i = 1:numel(areas) % this shows all the spots
% text(centroids(i,1),centroids(i,2),num2str(areas(i) ),'color','r')
% end
plot(centroids(ind,1),centroids(ind,2),'m*','markersize',32);
class(centroids)
centroid_x_robot= centroids(ind,1)
centroid_y_robot= centroids(ind,2)


%{
if centroid_y_robot < centroid_y_object-100
    dcm_2.Speed =0.75
    start(dcm_2)
elseif centroid_y_robot>centroid_y_object+100
        dcm_2.Speed=-0.75
        start(dcm_2)
else stop(dcm_2)
end
%}
    
disp(centroid_x_object)
disp(centroid_y_object)
disp(centroid_x_robot)
disp(centroid_y_robot)

if centroid_x_robot < centroid_x_detect-50
    dcm_1.Speed =1
    start(dcm_1)
elseif centroid_x_robot>centroid_x_detect+50
        dcm_1.Speed=-1
        start(dcm_1)

else stop(dcm_1)
end
if centroid_x_robot > centroid_x_detect-50 && centroid_x_robot<centroid_x_detect+50
stop(dcm_1)
break
end
end
while(true) 
if readVoltage(arduinoObj,'A8') >2.5 
    dcm_3.Speed= 1
    start(dcm_3)
else
    stop(dcm_3)
    if readVoltage(arduinoObj,'A9') >0.82
        dcm_2.Speed = 1
        start(dcm_2)
    else
        writeDigitalPin(a,D5,0)
        stop(dcm_2)
        pause(2)
        break
    end
end
end
while(true)
    if readVoltage(arduinoObj, 'A9')<1.5
        dcm_2.Speed = -1
        start(dcm_2)
    else 
        stop(dcm_2)
        if readVoltage(arduinoObj, 'A8')<2.9
            dcm_3.Speed = -1
            start(dcm_3)
        else
            stop(dcm_3)
            break
        end
    end
end

end

end